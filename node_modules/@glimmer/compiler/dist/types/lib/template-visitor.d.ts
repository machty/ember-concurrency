import { AST } from '@glimmer/syntax';
import { Core, Dict } from '@glimmer/interfaces';
export declare abstract class SymbolTable {
    static top(): ProgramSymbolTable;
    abstract has(name: string): boolean;
    abstract get(name: string): number;
    abstract getLocalsMap(): Dict<number>;
    abstract getEvalInfo(): Core.EvalInfo;
    abstract allocateNamed(name: string): number;
    abstract allocateBlock(name: string): number;
    abstract allocate(identifier: string): number;
    child(locals: string[]): BlockSymbolTable;
}
export declare class ProgramSymbolTable extends SymbolTable {
    symbols: string[];
    private size;
    private named;
    private blocks;
    has(_name: string): boolean;
    get(_name: string): never;
    getLocalsMap(): Dict<number>;
    getEvalInfo(): Core.EvalInfo;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
export declare class BlockSymbolTable extends SymbolTable {
    private parent;
    symbols: string[];
    slots: number[];
    constructor(parent: SymbolTable, symbols: string[], slots: number[]);
    has(name: string): boolean;
    get(name: string): number;
    getLocalsMap(): Dict<number>;
    getEvalInfo(): Core.EvalInfo;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
export declare namespace Action {
    type StartProgram = ['startProgram', [AST.Template, number, number[]]];
    type EndProgram = ['endProgram', [AST.Template, number]];
    type StartBlock = ['startBlock', [AST.Block, number, number[]]];
    type EndBlock = ['endBlock', [AST.Block, number]];
    type Block = ['block', [AST.BlockStatement, number, number]];
    type Mustache = ['mustache', [AST.MustacheStatement | AST.PartialStatement, number, number]];
    type OpenElement = ['openElement', [AST.ElementNode, number, number, number, number[]]];
    type CloseElement = ['closeElement', [AST.ElementNode, number, number]];
    type Text = ['text', [AST.TextNode, number, number]];
    type Comment = ['comment', [AST.CommentStatement, number, number]];
    type Action = StartProgram | EndProgram | StartBlock | EndBlock | Block | Mustache | OpenElement | CloseElement | Text | Comment;
}
export declare type Action = Action.Action;
export default class TemplateVisitor {
    private frameStack;
    actions: Action[];
    private programDepth;
    visit<S extends AST.TopLevelStatement>(node: S): void;
    Block(program: AST.Block): void;
    Template(program: AST.Template): void;
    anyBlock(program: AST.Block | AST.Template): void;
    ElementNode(element: AST.ElementNode): void;
    AttrNode(attr: AST.AttrNode): void;
    TextNode(text: AST.TextNode): void;
    BlockStatement(node: AST.BlockStatement): void;
    PartialStatement(node: AST.PartialStatement): void;
    CommentStatement(text: AST.CommentStatement): void;
    MustacheCommentStatement(): void;
    MustacheStatement(mustache: AST.MustacheStatement): void;
    private readonly currentFrame;
    private getCurrentFrame;
    private pushFrame;
    private popFrame;
}
//# sourceMappingURL=template-visitor.d.ts.map