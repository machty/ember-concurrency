"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ember_cli_entities_1 = require("../utilities/ember-cli-entities");
const copy_declarations_1 = __importDefault(require("../utilities/copy-declarations"));
exports.PRECOMPILE_MANIFEST = 'dist/.ts-precompile-manifest';
exports.default = ember_cli_entities_1.command({
    name: 'ts:precompile',
    works: 'insideProject',
    description: 'Generates JS and declaration files from TypeScript sources in preparation for publishing.',
    availableOptions: [{ name: 'manifest-path', type: String, default: exports.PRECOMPILE_MANIFEST }],
    run(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let outDir = `${os_1.default.tmpdir()}/e-c-ts-precompile-${process.pid}`;
            let { paths, rootDir, pathRoots } = this._loadConfig(outDir);
            if (!paths) {
                this.ui.writeLine('No `paths` were found in your `tsconfig.json`, so `ts:precompile` is a no-op.');
                return;
            }
            // prettier-ignore
            yield execa_1.default('tsc', [
                '--allowJs', 'false',
                '--noEmit', 'false',
                '--rootDir', rootDir || this.project.root,
                '--isolatedModules', 'false',
                '--declaration',
                '--declarationDir', outDir,
                '--emitDeclarationOnly',
            ]);
            let manifestPath = options.manifestPath;
            let packageName = this.project.pkg.name;
            // Ensure that if we are dealing with an addon that is using a different
            // addon name from its package name, we use the addon name, since that is
            // how it will be written for imports.
            let addon = this.project.addons.find(addon => addon.root === this.project.root);
            if (addon && addon.name !== packageName) {
                packageName = addon.name;
            }
            let createdFiles = copy_declarations_1.default(pathRoots, paths, packageName, this.project.root);
            fs_extra_1.default.mkdirsSync(path_1.default.dirname(manifestPath));
            fs_extra_1.default.writeFileSync(manifestPath, JSON.stringify(createdFiles.reverse()));
            fs_extra_1.default.remove(outDir);
        });
    },
    _loadConfig(outDir) {
        let ts = this.project.require('typescript');
        let configPath = ts.findConfigFile(this.project.root, ts.sys.fileExists);
        if (!configPath) {
            throw new Error('Unable to locate `tsconfig.json`');
        }
        let configSource = ts.readJsonConfigFile(configPath, ts.sys.readFile);
        let config = ts.parseJsonSourceFileConfigFileContent(configSource, ts.sys, path_1.default.dirname(configPath));
        let { paths, rootDir, baseUrl } = config.options;
        let configDir = path_1.default.dirname(configPath);
        let relativeBaseDir = path_1.default.relative(configDir, baseUrl || configDir);
        let pathRoots = [
            // Any declarations found in the actual source
            path_1.default.resolve(rootDir || configDir, relativeBaseDir),
            // Any declarations generated by `tsc`
            path_1.default.resolve(outDir, relativeBaseDir),
        ];
        return { rootDir, paths, pathRoots };
    },
});
