<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Global</title>

    <script src="scripts/prettify/prettify-709bfcc456c694bfe8ee86d184a1c360.js" integrity="sha256-iJ62JokFFH0hn3DfxUBSbuYjCfEU60uGpGI2G+sMATk= sha512-U96YfHWvwHOKaSJXqlNmcNL/j/ow3+EQp0Dferou+n15tEZ5TjS1WPbiu1yE10+HrlKwNYvr3JtPn9mpnUVUYg==" > </script>
    <script src="scripts/prettify/lang-css-914365fa44cd3c094afc7c0de229e29e.js" integrity="sha256-W/8u/xdnRt8pUf2OdHRfPyaq6lGTxTZQZsKHgKD/y4I= sha512-OsUG3GgeyMYQWj48BRAEUKSbafPqxNMaG6fkAKuvqQ9bIza9JNaxDiQ+H7ObiSv8eJvEaUHTnHJA6FLxpV0HZQ==" > </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow-3559834dc32d2cad6adeb2d2fed40e18.css" integrity="sha256-zInEqaMwHPE1XRPTqnMP2uZOEEYFQ2zjcasAv2R1nXg= sha512-DNQDuSSkAzc46N+QWE3KS1L9bV0TmwsRxFLYlC6kX3SP8nJmMl/33DgpGRmNKkm+TppbqCWXPhhin5iHk2K+WQ==" >
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default-594052a05e44d70859cdc4fb12075e1c.css" integrity="sha256-OucZHIVqEQk8qlXgv8+nPvbqL94vt9ahShp9sdYkX/U= sha512-a9TNVtnXumScv9GK2yf1iys25O5zcN8XoXFlPp8zWPkE6XSW3mQWjztV/9mDCj/0tgZAmlDiZWMaW3HUuVfkSw==" >
</head>

<body>

<div id="main">

    <h1 class="page-title">Global</h1>

    




<section>

<header>
    
        <h2></h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>


        
    
    </div>

    

    

    

    

    

    

    
        <h3 class="subsection-title">Members</h3>

        
            
<h4 class="name" id="all"><span class="type-signature">(constant) </span>all<span class="type-signature"></span></h4>




<div class="description">
    <p>A cancelation-aware variant of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a>.
The normal version of a <code>Promise.all</code> just returns a regular, uncancelable
Promise. The <code>ember-concurrency</code> variant of <code>all()</code> has the following
additional behavior:</p>
<ul>
<li>if the task that <code>yield</code>ed <code>all()</code> is canceled, any of the
<a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in to <code>all</code> will be canceled</li>
<li>if any of the <a href="TaskInstance.html"><code>TaskInstance</code></a>s (or regular promises) passed in reject (or
are canceled), all of the other unfinished <code>TaskInstance</code>s will
be automatically canceled.</li>
</ul>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="cancelable-promise-helpers.js.html">cancelable-promise-helpers.js</a>, <a href="cancelable-promise-helpers.js.html#line18">line 18</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id="allSettled"><span class="type-signature">(constant) </span>allSettled<span class="type-signature"></span></h4>




<div class="description">
    <p>A cancelation-aware variant of <a href="https://api.emberjs.com/ember/release/functions/rsvp/allSettled">RSVP.allSettled</a>.
The normal version of a <code>RSVP.allSettled</code> just returns a regular, uncancelable
Promise. The <code>ember-concurrency</code> variant of <code>allSettled()</code> has the following
additional behavior:</p>
<ul>
<li>if the task that <code>yield</code>ed <code>allSettled()</code> is canceled, any of the
<a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in to <code>allSettled</code> will be canceled</li>
</ul>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="cancelable-promise-helpers.js.html">cancelable-promise-helpers.js</a>, <a href="cancelable-promise-helpers.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id="forever"><span class="type-signature">(constant) </span>forever<span class="type-signature"></span></h4>




<div class="description">
    <p>Yielding <code>forever</code> will pause a task indefinitely until
it is cancelled (i.e. via host object destruction, the restartable modifier,
or manual cancellation).</p>
<p>This is often useful in cases involving animation: if you're
using Liquid Fire, or some other animation scheme, sometimes you'll
notice buttons visibly reverting to their inactive states during
a route transition. By yielding <code>forever</code> in a Component task that drives a
button's active state, you can keep a task indefinitely running
until the animation runs to completion.</p>
<p>NOTE: Liquid Fire also includes a useful <code>waitUntilIdle()</code> method
on the <code>liquid-fire-transitions</code> service that you can use in a lot
of these cases, but it won't cover cases of asynchrony that are
unrelated to animation, in which case <code>forever</code> might be better suited
to your needs.</p>
<pre class="prettyprint source lang-js"><code>import { task, forever } from 'ember-concurrency';
export default class MyComponent extends Component {
  &#64;service myService;
  myTask = task(async () => {
    await this.myService.doSomethingThatCausesATransition();
    await forever;
  });
}
</code></pre>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_yieldables.js.html">external/yieldables.js</a>, <a href="external_yieldables.js.html#line328">line 328</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id="hash"><span class="type-signature">(constant) </span>hash<span class="type-signature"></span></h4>




<div class="description">
    <p>A cancelation-aware variant of <a href="https://api.emberjs.com/ember/release/functions/rsvp/hash">RSVP.hash</a>.
The normal version of a <code>RSVP.hash</code> just returns a regular, uncancelable
Promise. The <code>ember-concurrency</code> variant of <code>hash()</code> has the following
additional behavior:</p>
<ul>
<li>if the task that <code>yield</code>ed <code>hash()</code> is canceled, any of the
<a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in to <code>hash</code> will be canceled</li>
<li>if any of the items rejects/cancels, all other cancelable items
(e.g. <a href="TaskInstance.html"><code>TaskInstance</code></a>s) will be canceled</li>
</ul>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="cancelable-promise-helpers.js.html">cancelable-promise-helpers.js</a>, <a href="cancelable-promise-helpers.js.html#line55">line 55</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id="hashSettled"><span class="type-signature">(constant) </span>hashSettled<span class="type-signature"></span></h4>




<div class="description">
    <p>A cancelation-aware variant of <a href="https://api.emberjs.com/ember/release/functions/rsvp/hashSettled">RSVP.hashSettled</a>.
The normal version of a <code>RSVP.hashSettled</code> just returns a regular, uncancelable
Promise. The <code>ember-concurrency</code> variant of <code>hashSettled()</code> has the following
additional behavior:</p>
<ul>
<li>if the task that <code>yield</code>ed <code>hashSettled()</code> is canceled, any of the
<a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in to <code>hashSettled</code> will be canceled</li>
</ul>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="cancelable-promise-helpers.js.html">cancelable-promise-helpers.js</a>, <a href="cancelable-promise-helpers.js.html#line66">line 66</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id="race"><span class="type-signature">(constant) </span>race<span class="type-signature"></span></h4>




<div class="description">
    <p>A cancelation-aware variant of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a>.
The normal version of a <code>Promise.race</code> just returns a regular, uncancelable
Promise. The <code>ember-concurrency</code> variant of <code>race()</code> has the following
additional behavior:</p>
<ul>
<li>if the task that <code>yield</code>ed <code>race()</code> is canceled, any of the
<a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in to <code>race</code> will be canceled</li>
<li>once any of the tasks/promises passed in complete (either success, failure,
or cancelation), any of the <a href="TaskInstance.html"><code>TaskInstance</code></a>s passed in will be canceled</li>
</ul>
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="cancelable-promise-helpers.js.html">cancelable-promise-helpers.js</a>, <a href="cancelable-promise-helpers.js.html#line42">line 42</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    
    <h4 class="name" id="animationFrame"><span class="type-signature"></span>animationFrame<span class="signature">()</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Yielding <code>animationFrame()</code> will pause a task until after the next animation
frame using the native <code>requestAnimationFrame()</code> browser API.</p>
<p>The task below, when performed, will print the time since the last loop run
for every animation frame.</p>
<pre class="prettyprint source lang-js"><code>export default class MyComponent extends Component {
  myTask = task(async () => {
    let lastNow = performance.now();
    while (true) {
      await animationFrame();

      let now = performance.now();
      let dt = now - lastNow;
      lastNow = now;

      console.log(dt);
    }
  });
}
</code></pre>
</div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_yieldables.js.html">external/yieldables.js</a>, <a href="external_yieldables.js.html#line294">line 294</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="didCancel"><span class="type-signature"></span>didCancel<span class="signature">(error)</span><span class="type-signature"> &rarr; {boolean}</span></h4>
    

    



<div class="description">
    <p>Returns true if the object passed to it is a TaskCancelation error.
If you call <code>someTask.perform().catch(...)</code> or otherwise treat
a <a href="TaskInstance.html"><code>TaskInstance</code></a> like a promise, you may need to
handle the cancelation of a TaskInstance differently from
other kinds of errors it might throw, and you can use this
convenience function to distinguish cancelation from errors.</p>
<pre class="prettyprint source lang-js"><code>click() {
  this.myTask.perform().catch(e => {
    if (!didCancel(e)) { throw e; }
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>error</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last"><p>the caught error, which might be a TaskCancelation</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_task-instance_cancelation.js.html">external/task-instance/cancelation.js</a>, <a href="external_task-instance_cancelation.js.html#line22">line 22</a>
    </li></ul></dd>
    

    

    

    
</dl>















<h5>Returns:</h5>

        


<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    





        
            

    

    
    <h4 class="name" id="getModifier"><span class="type-signature"></span>getModifier<span class="signature">(name)</span><span class="type-signature"> &rarr; (nullable) {<a href="TaskFactory.html#~TaskModifier">TaskFactory~TaskModifier</a>}</span></h4>
    

    



<div class="description">
    <p>Returns a specified modifier, if it exists in the registry</p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>Name of the modifier</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_task-factory.js.html">external/task-factory.js</a>, <a href="external_task-factory.js.html#line63">line 63</a>
    </li></ul></dd>
    

    

    

    
</dl>















<h5>Returns:</h5>

        


<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="TaskFactory.html#~TaskModifier">TaskFactory~TaskModifier</a></span>


    </dd>
</dl>

    





        
            

    

    
    <h4 class="name" id="hasModifier"><span class="type-signature"></span>hasModifier<span class="signature">(name)</span><span class="type-signature"> &rarr; {boolean}</span></h4>
    

    



<div class="description">
    <p>Returns whether a specified modifier exists in the registry</p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>Name of the modifier</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_task-factory.js.html">external/task-factory.js</a>, <a href="external_task-factory.js.html#line73">line 73</a>
    </li></ul></dd>
    

    

    

    
</dl>















<h5>Returns:</h5>

        


<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    





        
            

    

    
    <h4 class="name" id="rawTimeout"><span class="type-signature"></span>rawTimeout<span class="signature">(ms)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Yielding <code>rawTimeout(ms)</code> will pause a task for the duration
of time passed in, in milliseconds.</p>
<p>The timeout will use the native <code>setTimeout()</code> browser API,
instead of the Ember runloop, which means that test helpers
will <em>not</em> wait for it to complete.</p>
<p>The task below, when performed, will print a message to the
console every second.</p>
<pre class="prettyprint source lang-js"><code>export default class MyComponent extends Component {
  myTask = task(async () => {
    while (true) {
      console.log(&quot;Hello!&quot;);
      await rawTimeout(1000);
    }
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>ms</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>the amount of time to sleep before resuming
the task, in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_yieldables.js.html">external/yieldables.js</a>, <a href="external_yieldables.js.html#line356">line 356</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="registerModifier"><span class="type-signature"></span>registerModifier<span class="signature">(name, callback)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Registers a new modifier with the modifier registry</p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>Name of the modifier</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>callback</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="TaskFactory.html#~TaskModifier">TaskFactory~TaskModifier</a></span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="external_task-factory.js.html">external/task-factory.js</a>, <a href="external_task-factory.js.html#line47">line 47</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="task"><span class="type-signature"></span>task<span class="signature">(taskFunction)</span><span class="type-signature"> &rarr; {TaskProperty}</span></h4>
    

    



<div class="description">
    <p>A Task is a cancelable, restartable, asynchronous operation that
is driven by an async function. Tasks are automatically canceled
when the object they live on is destroyed (e.g. a Component
is unrendered).</p>
<p>To define a task, use the <code>task(...)</code> function, and pass in
an async arrow function, which will be invoked when the task
is performed. Async functions with the await keyword can
be used to elegantly express asynchronous, cancelable
operations.</p>
<p>The following Component defines a task called <code>myTask</code> that,
when performed, prints a message to the console, sleeps for 1 second,
prints a final message to the console, and then completes.</p>
<pre class="prettyprint source lang-js"><code>import Component from '@glimmer/component';
import { task, timeout } from 'ember-concurrency';

export default class MyComponent extends Component {
  myTask = task(async () => {
    console.log(&quot;Pausing for a second...&quot;);
    await timeout(1000);
    console.log(&quot;Done!&quot;);
  });
}
</code></pre>
<pre class="prettyprint source lang-hbs"><code>&lt;button {{action myTask.perform}}>Perform Task&lt;/button>
</code></pre>
<p>By default, tasks have no concurrency constraints
(multiple instances of a task can be running at the same time)
but much of a power of tasks lies in proper usage of Task Modifiers
that you can apply to a task.</p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>taskFunction</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>the async function backing the task.</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="task-public-api.js.html">task-public-api.js</a>, <a href="task-public-api.js.html#line44">line 44</a>
    </li></ul></dd>
    

    

    

    
</dl>















<h5>Returns:</h5>

        


<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">TaskProperty</span>


    </dd>
</dl>

    





        
            

    

    
    <h4 class="name" id="timeout"><span class="type-signature"></span>timeout<span class="signature">(ms)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Yielding <code>timeout(ms)</code> will pause a task for the duration
of time passed in, in milliseconds.</p>
<p>This timeout will be scheduled on the Ember runloop, which
means that test helpers will wait for it to complete before
continuing with the test. See <code>rawTimeout()</code> if you need
different behavior.</p>
<p>The task below, when performed, will print a message to the
console every second.</p>
<pre class="prettyprint source lang-js"><code>export default class MyComponent extends Component {
  myTask = task(async () => {
    while (true) {
      console.log(&quot;Hello!&quot;);
      await timeout(1000);
    }
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>ms</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>the amount of time to sleep before resuming
the task, in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="utils.js.html">utils.js</a>, <a href="utils.js.html#line61">line 61</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="waitForEvent"><span class="type-signature"></span>waitForEvent<span class="signature">(object, eventName)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Use <code>waitForEvent</code> to pause the task until an event is fired. The event
can either be a jQuery event or an Ember.Evented event (or any event system
where the object supports <code>.on()</code> <code>.one()</code> and <code>.off()</code>).</p>
<pre class="prettyprint source lang-js"><code>import { task, waitForEvent } from 'ember-concurrency';
export default class MyComponent extends Component {
  myTask = task(async () => {
    console.log(&quot;Please click anywhere..&quot;);
    let clickEvent = await waitForEvent($('body'), 'click');
    console.log(&quot;Got event&quot;, clickEvent);

    let emberEvent = await waitForEvent(this, 'foo');
    console.log(&quot;Got foo event&quot;, emberEvent);

    // somewhere else: component.trigger('foo', { value: 123 });
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>object</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last"><p>the Ember Object, jQuery element, or other object with .on() and .off() APIs
that the event fires from</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>eventName</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>the name of the event to wait for</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="wait-for.js.html">wait-for.js</a>, <a href="wait-for.js.html#line166">line 166</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="waitForProperty"><span class="type-signature"></span>waitForProperty<span class="signature">(object, key, callbackOrValue)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Use <code>waitForProperty</code> to pause the task until a property on an object
changes to some expected value. This can be used for a variety of use
cases, including synchronizing with another task by waiting for it
to become idle, or change state in some other way. If you omit the
callback, <code>waitForProperty</code> will resume execution when the observed
property becomes truthy. If you provide a callback, it'll be called
immediately with the observed property's current value, and multiple
times thereafter whenever the property changes, until you return
a truthy value from the callback, or the current task is canceled.
You can also pass in a non-Function value in place of the callback,
in which case the task will continue executing when the property's
value becomes the value that you passed in.</p>
<pre class="prettyprint source lang-js"><code>import { task, waitForProperty } from 'ember-concurrency';
export default class MyComponent extends Component {
  &#64;tracked foo = 0;

  myTask = task(async () => {
    console.log(&quot;Waiting for `foo` to become 5&quot;);

    await waitForProperty(this, 'foo', v => v === 5);
    // alternatively: await waitForProperty(this, 'foo', 5);

    // somewhere else: this.foo = 5;

    console.log(&quot;`foo` is 5!&quot;);

    // wait for another task to be idle before running:
    await waitForProperty(this, 'otherTask.isIdle');
    console.log(&quot;otherTask is idle!&quot;);
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>object</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last"><p>an object (most likely an Ember Object)</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>key</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>the property name that is observed for changes</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>callbackOrValue</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>a Function that should return a truthy value
when the task should continue executing, or
a non-Function value that the watched property
needs to equal before the task will continue running</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    
        <dt class="important tag-deprecated">Deprecated:</dt><dd><ul class="dummy"><li>Deprecated due to use of classic observers. Consider using a polling approach instead.</li></ul></dd>
    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="wait-for.js.html">wait-for.js</a>, <a href="wait-for.js.html#line218">line 218</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
            

    

    
    <h4 class="name" id="waitForQueue"><span class="type-signature"></span>waitForQueue<span class="signature">(queueName)</span><span class="type-signature"></span></h4>
    

    



<div class="description">
    <p>Use <code>waitForQueue</code> to pause the task until a certain run loop queue is reached.</p>
<pre class="prettyprint source lang-js"><code>import { task, waitForQueue } from 'ember-concurrency';
export default class MyComponent extends Component {
  myTask = task(async () => {
    await waitForQueue('afterRender');
    console.log(&quot;now we're in the afterRender queue&quot;);
  });
}
</code></pre>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>queueName</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>the name of the Ember run loop queue</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="wait-for.js.html">wait-for.js</a>, <a href="wait-for.js.html#line137">line 137</a>
    </li></ul></dd>
    

    

    

    
</dl>




















        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Task.html">Task</a></li><li><a href="TaskFactory.html">TaskFactory</a></li><li><a href="TaskInstance.html">TaskInstance</a></li><li><a href="Yieldable.html">Yieldable</a></li><li><a href="YieldableState.html">YieldableState</a></li></ul><h3>Global</h3><ul><li><a href="global.html#all">all</a></li><li><a href="global.html#allSettled">allSettled</a></li><li><a href="global.html#animationFrame">animationFrame</a></li><li><a href="global.html#didCancel">didCancel</a></li><li><a href="global.html#forever">forever</a></li><li><a href="global.html#getModifier">getModifier</a></li><li><a href="global.html#hasModifier">hasModifier</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hashSettled">hashSettled</a></li><li><a href="global.html#race">race</a></li><li><a href="global.html#rawTimeout">rawTimeout</a></li><li><a href="global.html#registerModifier">registerModifier</a></li><li><a href="global.html#task">task</a></li><li><a href="global.html#timeout">timeout</a></li><li><a href="global.html#waitForEvent">waitForEvent</a></li><li><a href="global.html#waitForProperty">waitForProperty</a></li><li><a href="global.html#waitForQueue">waitForQueue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 13 2025 16:04:22 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber-b072639105045a40275250bc66645306.js" integrity="sha256-TEufSbZ4Qwxf/IJCHQPJHfr9wjUfJpvHrtBv+gBKAh4= sha512-m4njB62kvXFnGPFIRSI6kNnkpeV9cKBk/seICNSJoAFnJbhYD1Bl1WdhlHLlTylsdwDdr4lXBPUE6VlUEPU7xg==" > </script>
</body>
</html>