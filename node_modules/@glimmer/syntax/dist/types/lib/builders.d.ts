import * as AST from './types/nodes';
import { Option, Dict } from '@glimmer/interfaces';
import { StringLiteral, BooleanLiteral, NumberLiteral } from './types/handlebars-ast';
export declare type BuilderPath = string | AST.PathExpression;
export declare type TagDescriptor = string | {
    name: string;
    selfClosing: boolean;
};
declare function buildMustache(path: BuilderPath | AST.Literal, params?: AST.Expression[], hash?: AST.Hash, raw?: boolean, loc?: AST.SourceLocation, strip?: AST.StripFlags): AST.MustacheStatement;
declare function buildBlock(path: BuilderPath, params: Option<AST.Expression[]>, hash: Option<AST.Hash>, _defaultBlock: AST.PossiblyDeprecatedBlock, _elseBlock?: Option<AST.PossiblyDeprecatedBlock>, loc?: AST.SourceLocation, openStrip?: AST.StripFlags, inverseStrip?: AST.StripFlags, closeStrip?: AST.StripFlags): AST.BlockStatement;
declare function buildElementModifier(path: BuilderPath, params?: AST.Expression[], hash?: AST.Hash, loc?: Option<AST.SourceLocation>): AST.ElementModifierStatement;
declare function buildPartial(name: AST.PathExpression, params?: AST.Expression[], hash?: AST.Hash, indent?: string, loc?: AST.SourceLocation): AST.PartialStatement;
declare function buildComment(value: string, loc?: AST.SourceLocation): AST.CommentStatement;
declare function buildMustacheComment(value: string, loc?: AST.SourceLocation): AST.MustacheCommentStatement;
declare function buildConcat(parts: (AST.TextNode | AST.MustacheStatement)[], loc?: AST.SourceLocation): AST.ConcatStatement;
export declare type ElementArgs = ['attrs', ...AttrSexp[]] | ['modifiers', ...ModifierSexp[]] | ['body', ...AST.Statement[]] | ['comments', ...ElementComment[]] | ['as', ...string[]] | ['loc', AST.SourceLocation];
export declare type PathSexp = string | ['path', string, LocSexp?];
export declare type ModifierSexp = string | [PathSexp, LocSexp?] | [PathSexp, AST.Expression[], LocSexp?] | [PathSexp, AST.Expression[], Dict<AST.Expression>, LocSexp?];
export declare type AttrSexp = [string, AST.AttrNode['value'] | string, LocSexp?];
export declare type LocSexp = ['loc', AST.SourceLocation];
export declare type ElementComment = AST.MustacheCommentStatement | AST.SourceLocation | string;
export declare type SexpValue = string | AST.Expression[] | Dict<AST.Expression> | LocSexp | PathSexp | undefined;
export declare function isLocSexp(value: SexpValue): value is LocSexp;
export declare function isParamsSexp(value: SexpValue): value is AST.Expression[];
export declare function isHashSexp(value: SexpValue): value is Dict<AST.Expression>;
export declare function normalizeModifier(sexp: ModifierSexp): AST.ElementModifierStatement;
export declare function normalizeAttr(sexp: AttrSexp): AST.AttrNode;
export declare function normalizeHash(hash: Dict<AST.Expression>, loc?: AST.SourceLocation): AST.Hash;
export declare function normalizePath(path: PathSexp): AST.PathExpression;
export declare function normalizeElementOptions(...args: ElementArgs[]): BuildElementOptions;
export interface BuildElementOptions {
    attrs?: AST.AttrNode[];
    modifiers?: AST.ElementModifierStatement[];
    children?: AST.Statement[];
    comments?: ElementComment[];
    blockParams?: string[];
    loc?: AST.SourceLocation;
}
declare function buildElement(tag: TagDescriptor, options?: BuildElementOptions): AST.ElementNode;
declare function buildElement(tag: TagDescriptor, ...options: ElementArgs[]): AST.ElementNode;
declare function buildAttr(name: string, value: AST.AttrNode['value'], loc?: AST.SourceLocation): AST.AttrNode;
declare function buildText(chars?: string, loc?: AST.SourceLocation): AST.TextNode;
declare function buildSexpr(path: BuilderPath, params?: AST.Expression[], hash?: AST.Hash, loc?: AST.SourceLocation): AST.SubExpression;
declare function buildPath(original: BuilderPath, loc?: AST.SourceLocation): AST.PathExpression;
declare function buildLiteral<T extends AST.Literal>(type: T['type'], value: T['value'], loc?: AST.SourceLocation): T;
declare function buildHash(pairs?: AST.HashPair[], loc?: AST.SourceLocation): AST.Hash;
declare function buildPair(key: string, value: AST.Expression, loc?: AST.SourceLocation): AST.HashPair;
declare function buildProgram(body?: AST.Statement[], blockParams?: string[], loc?: AST.SourceLocation): AST.Template;
declare function buildBlockItself(body?: AST.Statement[], blockParams?: string[], chained?: boolean, loc?: AST.SourceLocation): AST.Block;
declare function buildTemplate(body?: AST.Statement[], blockParams?: string[], loc?: AST.SourceLocation): AST.Template;
declare function buildPosition(line: number, column: number): {
    line: number;
    column: number;
};
export declare const SYNTHETIC: AST.SourceLocation;
declare function buildLoc(loc: Option<AST.SourceLocation>): AST.SourceLocation;
declare function buildLoc(startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): AST.SourceLocation;
declare const _default: {
    mustache: typeof buildMustache;
    block: typeof buildBlock;
    partial: typeof buildPartial;
    comment: typeof buildComment;
    mustacheComment: typeof buildMustacheComment;
    element: typeof buildElement;
    elementModifier: typeof buildElementModifier;
    attr: typeof buildAttr;
    text: typeof buildText;
    sexpr: typeof buildSexpr;
    path: typeof buildPath;
    concat: typeof buildConcat;
    hash: typeof buildHash;
    pair: typeof buildPair;
    literal: typeof buildLiteral;
    program: typeof buildProgram;
    blockItself: typeof buildBlockItself;
    template: typeof buildTemplate;
    loc: typeof buildLoc;
    pos: typeof buildPosition;
    string: (value: string) => StringLiteral;
    boolean: (value: boolean) => BooleanLiteral;
    number: (value: number) => NumberLiteral;
    undefined(): AST.Literal;
    null(): AST.Literal;
};
export default _default;
//# sourceMappingURL=builders.d.ts.map